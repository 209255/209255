\documentclass[12pt,a4paper,titlepage]{article}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{graphicx}
\selectlanguage{polish}
\setlength{\parindent}{5mm} %ustawi rozmiar wcie˛cia na pocza˛tku kaz˙dego akapitu na 0mm,
\setlength{\parskip}{4mm} %
\title{Sprawozdanie z ćwiczenia laboratoryjnego V\newline Drzewa BST i AVL}
\date{17.04.2015}
\author{Bartłomiej Ankowski}
\begin{document}
\maketitle
\pagestyle{empty}
%\pagestyle{headings}
\tableofcontents
\section{Wstęp}
Celem tego laboratorium było zamodelowanie dwóch struktur danych: Drzewo BST i AVL.
Następnię został wykonany pomiar czasów zapisu i odczytu danych dla tych struktur.
\section{Złożoność obliczeniowa}
\subsection{Drzewo AVL}

Drzewo AVL posiada mechanizm autobalansujący strukturę drzewa.Dzieję się tak za sprawą rotacji: lewych,prawycj bądź mieszanych wykonywanych w momencie,gdy moduł współczynnika balansujący bedzię wiekszy od 1.Współczynnik ten jest wyznaczany jako różnica lewego i prawego poddrzewa.Drzewo jest wyważone jeśli dla każdego węzła liczba węzłow w jego lewym i prawym poddrzewiu różni się maksymalnie o jeden.
Złożoność obliczeniowa wynikająca jest nieco większa niż w przypadku drzewa BST, lecz własności drzewa AVL powodują, że czas odczytu i zapisu nie powinien przekroczyć $1,44log_2n$, gdzie $n$ jest liczbą wezłów.
Zatem złożoność oblcizeniowa operacji zapisu i odczytu wynosi $O(log_2n)$.

\subsection{Drzewo BST}

\subsubsection{Zapis}
Algorytm dodawania węzła w sposób rekurencyjny wykonuje się od korzenia w stronę liści,poruszając sie w lewo lub w prawo, w zależności od wyniku porównania z napotkanymi węzłami.W momencie dotarcia do jednego z liści następuje ostanie porównanie wartości , po czym nowy węzeł staje się lewym bądź prawym synem węzła, który był liściem.
Złożoność tej operacji wynosi $O(h)$, gdzie h jest wysokością drzewa, wyrażającą się wzorem $log_2n$, zatem całkowita złożoność wynosi $O(log_2n)$.

Kostrukcja takiego drzewa nie posiada żadnych mechanizmów urzymująycych strukturę w zakładanym porządku.
Może zatem dojść do sytuacji, że drzewo utraci swoją strukturę i zdegeneruję się do postaci listy.
W takim przypadku złożoność obliczeniowa wyniesie $O(n)$, ponieważ dodanie nowego węzła wymusi przejście wszystkich elementów od korzenia, aż do liścia.
\subsubsection{Odczyt}
Algorytm Znajdowania interesującego nas węzła jest proporcjonalny do wysokości drzewa.
Wykonywane są rekurencyjne wywoływania dla kolejnych lewych bądź prawych węzłów, aż do momentu natrafienia na szukaną wartość. Złożoność tej operacji wynosi zatem $O(log_2n)$.

W przypadku, gdy doszło do zdegenerowania struktury podczas zapisu, przełoży się to również na złożoność obliczeniową odczytu.Zlożoność w takim przypadku wyniesie również $O(log_2n)$
\section{Wyniki pomiarów}
\subsection{Odczyt}
\begin{table}[h]
\begin{tabular}{|l|l|l|l|l|}
\hline
Ilość danych[n] & AVL pes[us] &AVL[us]   & BST[us] & BST pes[us]  \\ \hline
50 &0,112 &0,166  &0,190 & 0,724\\ \hline
100 &0,114  &0,143  &0,180  & 1,353 \\ \hline
500 &0,177  &0,068  &0,261  &1,660  \\ \hline
1000 &0,125  &0,067  &0,102  &3,352  \\ \hline
5000 &0,101  &0,0673  &0,0768  &17,21  \\ \hline
10000 &0,106  &0,0677  &0,0743  & 34,93 \\ \hline
50000 &0,150  &0,0689  &0,07338  &-  \\ \hline
100000 &0,171  &0,0677  &0,0783  &-  \\ \hline
500000 &0,232  & 0,0672 &-  &-  \\ \hline
1000000 &0,252  &0,0677  &  &-  \\ \hline
\end{tabular}
\caption{Wyniki odczytu pojedynczgo elementu dla drzew AVL i BST}
\end{table}
\newpage
\begin{figure}[!htbp]
%\begin{center}
\includegraphics[scale=0.6]{odczytAVL.png}
\caption{Wyniki odczytu pojedynczgo elementu dla drzewa AVL}
%\end{center}
\end{figure}
\newpage
\begin{figure}[!htbp]
%\begin{center}
\includegraphics[scale=0.6]{OdczytBST.png}
\caption{Wyniki odcztu pojedynczego elementu dla drzewa BST}
%\end{center}
\end{figure}
\subsection{Zapis}

\begin{table}[h]
\begin{tabular}{|l|l|l|l|l|}
\hline
Ilość danych[n] & AVL pes[us] &AVL[us]   & BST[us] & BST pes[us]  \\ \hline
50 &0,784  &0,826 &0,128 &0,762 \\ \hline
100 &0,885  &1,032 &0,126  &1,405  \\ \hline
500 &0,960  &1,393 &0,225 &3,140  \\ \hline
1000 &0,320  &0,758 &0,296 &3,363  \\ \hline
5000 &0,384  &0,460 &0,412 &17,07  \\ \hline
10000 &0,417  &0,492&0,58 &35,010  \\ \hline
50000 &0,515  &0,585&4,121 & - \\ \hline
100000 &0,563  &0,628&105,0 &-  \\ \hline
500000 &0,694  &0,738& - & - \\ \hline
1000000 &0,753  &0,782&-  &-  \\ \hline
\end{tabular}
\end{table}
\newpage
\begin{figure}[!htbp]
%\begin{center}
\includegraphics[scale=0.6]{zapisBST.png}
\caption{Wyniki zapisu pojedynczego elementu dla drzewa BST}
%\end{center}
\end{figure}
\newpage
\begin{figure}[!htbp]
%\begin{center}
\includegraphics[scale=0.6]{zapisAVL.png}
\caption{Wyniki zapisu pojedynczego elementu dla drzewa AVL}
%\end{center}
\end{figure}
\section{Wnioski}
\begin{itemize}
\item Zastosowanie mechanizmów balansyjących drzewo AVL przyniosło zamierzany efekt.
Przy podaniu na wejście programu danych posortowanych rosnąco, drzwo nie degeneruję się do postaci listy.
Złożoność operacji odczytu i zapisu dla drzewa AVL są zatem zgodne z teoretyczną i wynosi $O(log_2n)$
\item W przyadku podania danych losowych na wejście dla drzewa AVL, prawidłową złożoność posiada operacja zapisu danych.Natomiast w przypadku operacji odczytu danych, otrzymane wyniki nie są zgodne z teoretycznymi.
Sprawa jest o tyle dziwna, że monitorowanie pracy programu dla tego przypadku wykazało, że wyszukiwanie danych wartości na podstawie klucza odbywa sie prawidłowo.Mimo to otrzymane wyniki świadczą o tym,że program zbyt wcześnie zakończył swoja pracę.

\item Podanie na wejście danych losowych dla drzewa binarnego,nie prawidołową zlożoność posiada operacje zapisu,ponieważ dla ilości danych powyżej 10k, złożoność jest liniowa.
\item W przypadku operacji odczytu dla drzewa binarnego, podanie na wejście danych losowych powoduję przypadek podobny jak dla drzewa AVL.
\item Podanie na wejście programu danych posortowanych rosnąco dla drzewa binarnego powoduję, degenerację drzewa do postaci listy.
\end{itemize}
\end{document}
